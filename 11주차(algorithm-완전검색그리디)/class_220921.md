## 완전검색&그리디

### 반복과 재귀
- 반복과 재귀는 유사한 작업을 수행한다.
- 반복은 수행하는 작업이 완료될 때 까지 계속 반복
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

#### 반복을 이용한 선택정렬
```python
def SelectionSort(A):

    n = len(A)

    for i in range(0, n-1):
        minI = i
        for j in range(i+1, n):
            if A[j] < A[minI]:
                minI = j
        A[minI], A[i] = A[i], A[minI]
```
#### 재귀를 이용한 선택정렬
```python
# 재귀
def selection_sort2(arr, i):

    # 기저조건
    if i >= len(arr):
        return
    # 작은 문제의 결과를 통해 큰 문제를 해결하는 유도 조건

    # 현재 위치가 0일때부터 길이 -1 위치의 자리를 찾는다.
    # 작은 문제는 현재위치가 i 일때의 그 위치에 맞는 원소를 찾아 자리를 바꾼다.
    min_idx = i # 최소 원소의 위치를 일단 i로 시작
    for j in range(i+1, len(arr)):
        if arr[j] < arr[min_idx]:
            min_idx = j
    arr[i], arr[min_idx] = arr[min_idx], arr[i]
    # ==========================================
    # i 다음 위치로 가서 (i+1) 그 위치에 맞는 최소값을 찾아 바꾸는 일을 한다.
    selection_sort2(arr, i+1)

arr = [9, 5, 7, 6, 8, 1, 4, 3, 2, 0, 10]

selection_sort2(arr, 0)

print(arr)
```

#### 팩토리얼 재귀 함수
- n!에 대한 재귀함수
```python
def fact(n):
    if n <= 1:
        return 1
    else:
        return n * fact(n-1)
```

**입력값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.**

#### 2^k 연산에 대한 재귀와 반복
```python
# 재귀
def Poser_of_2(k):
    if k == 0:
        return 1
    else:
        return 2 * Power_of_2(k-1)

# 반복
def Power_of_2(k):
    i = 0
    power = 1
    while i < k:
        power = power * 2
        i = l + 1
    return power
```

**검정등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바랍직하다.**

### 완전 검색
- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는것이다.
- 또한 이들은 전형적으로 순열, 조합, 그리고 부분집합과 같은 조합적 문제들과 연관된다.
- 완전 검색은 조합적 문제에 대한 brute-force 방법이다.

#### 부분집합
- 집합에 포함된 원소들을 선택하는 것이다.
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다.
- N개의 원소를 포함한 집합
  - 자기 자신과 공집합 포함한 모든 부분집합의 개수는 2^n개
  - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

#### 바이너리 카운팅을 톤한 사전적 순서
- 부분집합을 생성하기 위한 가장 자연스러운 방법
- 바이너리 카운팅은 사전적 순서로 생성하기 위한 가장 간단한 방법이다.

#### 바이너리 카운팅
- 원소수에 해당하는 N개의 비트열을 이용한다.
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.

```python
# 바이너리 카운팅을 통한 부분집합 생성 코드 예
arr = [3,6,7,1,5,4]
n = len(arr)

for i in range(0,(1<<n)): # 1<<n : 부분집합의 개수
    for j in range(0, n): # 원소의 수만큼 비트를 비교함
        if i &(1<<j):     # i의 j번째 비트가 1이면 j번째 원소 출력
            print('%d'%arr[j],end='')
    print()
```

#### 조합(C)
- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합이라고 부른다.
```python
# 재귀호출을 이용한 조합 생성 알고리즘
an[] : n개의 원소를 가지고 있는 배열
tr[] : r개의 크기의 배열, 조합이 임시 저장될 배열

def comb(n, r):
    if r==0:
        print(arr)
    else:
        if n < r:
            return
        else:
            tr[r-1] = an[n-1]
            comb(n-1, r-1)
            comb(n-1, r)
```

### 탐욕(Greedy) 알고리즘
- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
- 여러 경우 중 하나를 선택 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 일단, 한번 선택된 것은 번복하지 않는다. 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다.
- 최적화 문제한 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.

#### 탐욕 알고리즘의 동작 과정
1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합에 추가한다.
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는 지를 검사한다.
3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

#### 탐욕 기법을 적용한 거스름돈 줄이기
1. 해 선택 : 여기에선는 멀리 내다볼 것 없이 가장 좋은 해를 선택한다. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들므로 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가한다.
2. 실행 가능성 검사 : 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가한다.
3. 해 검사 : 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내드려야 하는 액수와 일치하는 셈이다. 더 드려도, 덜 드려도 안되기 때문에 거스름돈을 확인해서 액수에 모자라면 다시 1로 돌아가서 거스름돈에 추가할 동전을 고른다.

**최적해를 반드시 구한다는 보장이 없다.**

#### 탐욕 알고리즘의 필수 요소
- 탐욕적 선택 속성
  - 탐욕적 선택은 최적해로 갈수 있음을 보여라 -> 즉, 탐욕적 선택은 항상 안전하다.
- 최적 부분 구조
  - 최적화 문제를 정형화하라 -> 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
- **(원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해)** 임을 증명해라

#### 탐욕 기법과 동적 계획법의 비교
- 탐욕기법
    1. 매 단계에서, 가장 좋게 보이는 것을 빠르게 선택한다. -> 지역 최적 선택
    2. 하위 문제를 풀기 전에(탐욕적) 선택이 먼저 이루어진다.
    3. Top-down 방식
    4. 일반적으로 빠르고 간결하다
- 동적 계획법
    1. 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다.
    2. 하위 문제가 우선 해결된다.
    3. Bottom-up 방식
    4. 좀 더 느리고 복잡하다